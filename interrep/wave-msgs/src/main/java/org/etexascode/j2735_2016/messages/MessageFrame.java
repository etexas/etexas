/*-
 * #%L
 * eTEXAS
 * %%
 * Copyright (C) 2016 - 2018 Harmonia Holdings Group, LLC
 * %%
 * All rights reserved.
-
SBIR DATA RIGHTS
Harmonia Holdings Group, LLC
2020 Kraft Drive Suite 2400
Blacksburg, VA 24060
Contract No: DTRT57-16-c-10008
Start Date: 01/05/2016
End Date: 01/05/2018
Expiration of SBIR Data Rights Period: 01/05/2022
-
The Government's rights to use, modify, reproduce, release, perform,
display, or disclose technical data or computer software marked with
this legend are restricted during the period shown as provided in
paragraph (b)(4) of the Rights in Noncommercial Technical Data and
Computer Software-Small Business Innovation Research (SBIR) Program
clause contained in the above identified contract. No restrictions
apply after the expiration date shown above. Any reproduction of
technical data, computer software, or portions thereof marked with
this legend must also reproduce the markings.
-
Contributors:
Harmonia Holdings Group LLC: Initial API and implementation.
 * #L%
 */
package org.etexascode.j2735_2016.messages;

import java.util.Objects;

import org.etexascode.j2735_2016.elements.DSRCmsgID;
import org.etexascode.j2735_2016.util.UPERBytes;
import org.etexascode.j2735_2016.util.UPERInteger;

/**
 * The message frame for the j2735 2016 specification.
 * 
 * @author ttevendale
 */
public class MessageFrame {

    /**
     * The DSRC message ID element.
     */
    private DSRCmsgID messageId;

    /**
     * The message bits. NOTE: this does not include the message frame bits.
     */
    private String bits;

    /**
     * Constructs a message frame.
     * 
     * @param messageId The DSRC message ID element.
     * @param bits The message bits to frame.
     */
    public MessageFrame(DSRCmsgID messageId, String bits) {

        this.messageId = Objects.requireNonNull(messageId);
        this.bits = Objects.requireNonNull(bits);
    }

    /**
     * Constructs a message frame (primitive).
     * 
     * @param messageId The DSRC message ID.
     * @param bits The message bits to frame.
     */
    public MessageFrame(int messageId, String bits) {

        this(new DSRCmsgID(messageId), bits);
    }

    /**
     * Encodes a message frame with the DSRC message ID and message bits.
     * 
     * @return The Hexadecimal message.
     */
    public String encodeHexUPER() {

        StringBuilder frame = new StringBuilder();

        // we aren't planning on having the extension usable so setting to off.
        frame.append('0');
        frame.append(messageId.encodeUPER());

        // pad
        int byteSize = 8;
        int remaining = bits.length() % byteSize;
        if (remaining != 0) {

            StringBuilder bitsStringBuilder = new StringBuilder(bits);
            int paddedZerosNeeded = byteSize - remaining;
            for (int i = 0; i < paddedZerosNeeded; i++) {

                bitsStringBuilder.append('0');
            }
            bits = bitsStringBuilder.toString();
        }

        // numBytes is handled this way because this is what happened when using the classes
        // generated by the ASN1 Compiler from Objective Systems ASN1C
        int numBytes = bits.length() / 8;
        if (numBytes <= 127) {

            frame.append(UPERInteger.encode(numBytes, 0, 8));
        }
        else if (numBytes <= 2340) {

            frame.append("1000");
            frame.append(UPERInteger.encode(numBytes, 0, 12));
        }
        else {

            throw new IllegalStateException("There are more bytes than can fit in a single message frame");
        }
        frame.append(bits);

        return UPERBytes.decode(frame.toString());
    }

    /**
     * Gets the DSRC message ID from the provided hexadecimal bytes.
     * 
     * @param bytes The bytes to get the DSRC message ID from.
     * @return The DSRC message ID.
     */
    public static int getDSRCMessageId(String bytes) {

        String bits = UPERBytes.encode(bytes.substring(0, 4));

        // getting rid of extension bit
        bits = bits.substring(1);
        DSRCmsgID messageId = new DSRCmsgID(Integer.parseInt(bits, 2));

        return messageId.getValue();
    }

    /**
     * Decodes a basic safety message (2016).
     * 
     * @param bytes The basic safety message to decode.
     * @return The decoded basic safety message.
     */
    public static BasicSafetyMessage decodeBSM(String bytes) {

        bytes = stripMessageFrame(bytes);
        BasicSafetyMessage bsm = new BasicSafetyMessage();
        bsm.decodeUPER(UPERBytes.encode(bytes));
        return bsm;
    }

    /**
     * Decodes a common safety request (2016).
     * 
     * @param bytes The common safety request to decode.
     * @return The decoded common safety request.
     */
    public static CommonSafetyRequest decodeCSR(String bytes) {

        bytes = stripMessageFrame(bytes);
        CommonSafetyRequest csr = new CommonSafetyRequest();
        csr.decodeUPER(UPERBytes.encode(bytes));
        return csr;
    }

    /**
     * Decodes a map data message (2016).
     * 
     * @param bytes The map data to decode.
     * @return The decoded map data.
     */
    public static MapData decodeMapData(String bytes) {

        bytes = stripMessageFrame(bytes);
        MapData mapData = new MapData();
        mapData.decodeUPER(UPERBytes.encode(bytes));
        return mapData;
    }

    /**
     * Decodes a signal phase and timing message (2016).
     * 
     * @param bytes The signal phase and timing to decode.
     * @return The decoded signal phase and timing.
     */
    public static SPAT decodeSPAT(String bytes) {

        bytes = stripMessageFrame(bytes);
        SPAT spat = new SPAT();
        spat.decodeUPER(UPERBytes.encode(bytes));
        return spat;
    }

    /**
     * Strips the MessageFrame portion of a message.
     * 
     * @param bytes The bytes to have the MessageFrame striped from.
     * @return The remaining bytes.
     */
    private static String stripMessageFrame(String bytes) {

        String stripedBytes;
        if (bytes.charAt(4) == '8') {

            stripedBytes = bytes.substring(8);
        }
        else {

            stripedBytes = bytes.substring(6);
        }

        int numBytes = bytes.length() / 2;

        if (numBytes > 2340) {

            throw new IllegalStateException("There are more bytes than can be successfully decoded");
        }

        return stripedBytes;
    }
}
